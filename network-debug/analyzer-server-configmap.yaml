apiVersion: v1
kind: ConfigMap
metadata:
  name: analyzer-server
  namespace: kube-system
data:
  server.py: |
    import http.server
    import socketserver
    import os
    import glob
    import datetime
    import socket
    import urllib.parse
    import os

    # Get the node name from environment variable (set by Kubernetes Downward API)
    # If not set, fall back to hostname
    NODE_NAME = os.environ.get('NODE_NAME', socket.gethostname())
    PORT = 8080

    class CaptureHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            if self.path == '/':
                self.send_response(200)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                
                html = f"""
                <html>
                <head>
                    <title>tcpdump Capture Analyzer</title>
                    <style>
                        body {{ font-family: Arial, sans-serif; margin: 20px; }}
                        h1 {{ color: #333; }}
                        h2 {{ color: #555; }}
                        table {{ border-collapse: collapse; width: 100%; }}
                        th, td {{ text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }}
                    </style>
                </head>
                <body>
                    <h1>tcpdump Capture Analyzer</h1>
                    
                    <h2>Current Node: {NODE_NAME}</h2>
                    <p>This analyzer is running on node <strong>{NODE_NAME}</strong> and showing capture files from this node.</p>
                    
                    <h2>Capture Files</h2>
                    {self.list_capture_files()}
                </body>
                </html>
                """
                
                self.wfile.write(html.encode())
                return
            elif self.path.startswith('/download?file='):
                try:
                    print(f"Download request received: {self.path}")
                    
                    # Parse the file path from the query string
                    query = urllib.parse.urlparse(self.path).query
                    file_path = urllib.parse.parse_qs(query)['file'][0]
                    print(f"Requested file path: {file_path}")
                    
                    # Validate the file path (must be in /captures directory)
                    if not file_path.startswith('/captures/'):
                        print(f"Access denied: Path does not start with /captures/: {file_path}")
                        self.send_error(403, "Access denied")
                        return
                        
                    if not os.path.exists(file_path):
                        print(f"File not found: {file_path}")
                        self.send_error(404, "File not found")
                        return
                    
                    file_size = os.path.getsize(file_path)
                    print(f"File exists, size: {file_size} bytes")
                    
                    # Serve the file for download
                    self.send_response(200)
                    self.send_header('Content-type', 'application/octet-stream')
                    self.send_header('Content-Length', str(file_size))
                    self.send_header('Content-Disposition', f'attachment; filename="{os.path.basename(file_path)}"')
                    self.end_headers()
                    
                    # Read and send the file in chunks to avoid memory issues with large files
                    with open(file_path, 'rb') as f:
                        chunk_size = 8192  # 8KB chunks
                        while True:
                            chunk = f.read(chunk_size)
                            if not chunk:
                                break
                            try:
                                self.wfile.write(chunk)
                            except BrokenPipeError:
                                print("Client disconnected during download")
                                return
                    
                    print(f"File download completed: {file_path}")
                    return
                except Exception as e:
                    print(f"Error during download: {str(e)}")
                    import traceback
                    traceback.print_exc()
                    self.send_error(500, f"Internal server error: {str(e)}")
                    return
            else:
                self.send_error(404, "File not found")
                return
        
        def list_capture_files(self):
            node_dir = f"/captures/{NODE_NAME}"
            files_html = []
            
            if os.path.exists(node_dir):
                pcap_files = glob.glob(f"{node_dir}/*.pcap*")
                
                if pcap_files:
                    files_html.append("<table border='1' cellpadding='5' cellspacing='0'>")
                    files_html.append("<tr><th>Interface</th><th>Size</th><th>Last Modified</th><th>Actions</th></tr>")
                    
                    for pcap_file in pcap_files:
                        interface = os.path.basename(pcap_file).replace('.pcap', '').replace('.pcap0', '')
                        
                        stat = os.stat(pcap_file)
                        size = f"{stat.st_size / (1024*1024):.2f} MB"
                        modified = datetime.datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
                        
                        files_html.append("<tr>")
                        files_html.append(f"<td>{interface}</td>")
                        files_html.append(f"<td>{size}</td>")
                        files_html.append(f"<td>{modified}</td>")
                        files_html.append(f"<td><a href='/download?file={pcap_file}'>Download</a></td>")
                        files_html.append("</tr>")
                    
                    files_html.append("</table>")
                else:
                    files_html.append("<p>No capture files found on this node.</p>")
            else:
                files_html.append(f"<p>Capture directory {node_dir} not found.</p>")
            
            return "".join(files_html)

    print(f"Starting HTTP server on port {PORT}")
    
    # Add error handling for server startup and request handling
    try:
        # Allow reusing the address if the previous server crashed
        socketserver.TCPServer.allow_reuse_address = True
        
        with socketserver.TCPServer(("", PORT), CaptureHandler) as httpd:
            print(f"Serving at port {PORT}")
            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                print("Server stopped by keyboard interrupt")
            except Exception as e:
                print(f"Server error: {str(e)}")
                import traceback
                traceback.print_exc()
    except OSError as e:
        if e.errno == 98:  # Address already in use
            print(f"Error: Port {PORT} is already in use")
            print("Trying to use a different port...")
            
            # Try a different port
            for alt_port in range(PORT + 1, PORT + 10):
                try:
                    print(f"Attempting to start server on port {alt_port}...")
                    with socketserver.TCPServer(("", alt_port), CaptureHandler) as httpd:
                        print(f"Serving at port {alt_port}")
                        httpd.serve_forever()
                        break
                except OSError:
                    print(f"Port {alt_port} is also in use, trying next port...")
        else:
            print(f"Error starting server: {str(e)}")
            import traceback
            traceback.print_exc()
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        import traceback
        traceback.print_exc()