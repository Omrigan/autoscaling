apiVersion: v1
kind: ConfigMap
metadata:
  name: tcpdump-scripts
  namespace: kube-system
data:
  capture.sh: |
    #!/bin/bash
    set -e

    # Create directory for captures
    mkdir -p /captures
    
    # Get node name
    NODE_NAME=$(hostname)
    
    # Create node directory
    mkdir -p "/captures/$NODE_NAME"
    
    # Detect bridge interfaces
    # Common bridge interfaces in Kubernetes environments
    BRIDGE_INTERFACES=""
    DETECTED_INTERFACES=()
    
    echo "Scanning for bridge interfaces..."
    # Check for bridge interfaces
    for iface in $(ip link show type bridge 2>/dev/null | grep -o -E '^[0-9]+: [^:]+' | awk '{print $2}' 2>/dev/null || echo ""); do
      echo "Found bridge interface: $iface"
      if [[ ! " ${DETECTED_INTERFACES[@]} " =~ " ${iface} " ]]; then
        DETECTED_INTERFACES+=("$iface")
        BRIDGE_INTERFACES="$BRIDGE_INTERFACES $iface"
      fi
    done
    
    echo "Checking for common CNI bridges..."
    # Check for common CNI bridges
    for bridge in cni0 cbr0 cilium_host cilium_net br-int br0 docker0 neon-br0; do
      if ip link show $bridge &>/dev/null; then
        echo "Found CNI bridge: $bridge"
        if [[ ! " ${DETECTED_INTERFACES[@]} " =~ " ${bridge} " ]]; then
          DETECTED_INTERFACES+=("$bridge")
          BRIDGE_INTERFACES="$BRIDGE_INTERFACES $bridge"
        fi
      fi
    done
    
    echo "Scanning for vxlan interfaces..."
    # Check for vxlan interfaces
    for iface in $(ip link show type vxlan 2>/dev/null | grep -o -E '^[0-9]+: [^:]+' | awk '{print $2}' 2>/dev/null || echo ""); do
      echo "Found vxlan interface: $iface"
      if [[ ! " ${DETECTED_INTERFACES[@]} " =~ " ${iface} " ]]; then
        DETECTED_INTERFACES+=("$iface")
        BRIDGE_INTERFACES="$BRIDGE_INTERFACES $iface"
      fi
    done
    
    # Log detected interfaces
    echo "Detected bridge/overlay interfaces on $NODE_NAME: $BRIDGE_INTERFACES"
    
    # If no interfaces found, check all interfaces
    if [ -z "$BRIDGE_INTERFACES" ]; then
      echo "No bridge interfaces found, will monitor all non-loopback interfaces"
      echo "Listing all available interfaces:"
      ip link show
      
      echo "Selecting all non-loopback interfaces..."
      BRIDGE_INTERFACES=$(ip -o link show 2>/dev/null | grep -v "lo:" | awk -F': ' '{print $2}' | cut -d'@' -f1 2>/dev/null || echo "eth0")
      echo "Selected interfaces: $BRIDGE_INTERFACES"
    fi
    
    # Function to start tcpdump for an interface
    start_tcpdump() {
      local interface=$1
      local output_dir="/captures/$NODE_NAME"
      local max_size_mb=100
      local rotate_count=5
      
      mkdir -p "$output_dir"
      
      echo "Starting tcpdump on interface $interface"
      
      # Run tcpdump with file rotation
      tcpdump -i "$interface" -s 0 -n -w "$output_dir/$interface.pcap" -W "$rotate_count" -C "$max_size_mb" &
      
      # Store PID for potential cleanup
      echo $! > "/captures/$NODE_NAME/$interface.pid"
    }
    
    # Start tcpdump for each interface
    for interface in $BRIDGE_INTERFACES; do
      start_tcpdump "$interface"
    done
    
    # Log summary
    echo "tcpdump started on node $NODE_NAME for interfaces: $BRIDGE_INTERFACES"
    echo "Capture files are stored in /captures/$NODE_NAME/"
    
    # Keep the container running
    tail -f /dev/null

  analyzer.sh: |
    #!/bin/bash
    set -e

    # Create directory for captures
    mkdir -p /captures
    mkdir -p /tmp/analysis

    # Get node name
    NODE_NAME=$(hostname)
    
    echo "Starting packet capture analyzer service on node $NODE_NAME..."

    # Try to install Python
    echo "Installing Python..."
    apk update && apk add --no-cache python3 || true

    # Create a simple Python HTTP server script
    cat > /tmp/analysis/server.py << 'EOF'
import http.server
import socketserver
import os
import glob
import datetime
import socket
import urllib.parse

# Get the node name
NODE_NAME = socket.gethostname()
PORT = 8080

class CaptureHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            
            html = f"""
            <html>
            <head>
                <title>tcpdump Capture Analyzer</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 20px; }}
                    h1 {{ color: #333; }}
                    h2 {{ color: #555; }}
                    table {{ border-collapse: collapse; width: 100%; }}
                    th, td {{ text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }}
                </style>
            </head>
            <body>
                <h1>tcpdump Capture Analyzer</h1>
                
                <h2>Current Node: {NODE_NAME}</h2>
                <p>This analyzer is running on node <strong>{NODE_NAME}</strong> and showing capture files from this node.</p>
                
                <h2>Capture Files</h2>
                {self.list_capture_files()}
            </body>
            </html>
            """
            
            self.wfile.write(html.encode())
            return
        elif self.path.startswith('/download?file='):
            # Parse the file path from the query string
            query = urllib.parse.urlparse(self.path).query
            file_path = urllib.parse.parse_qs(query)['file'][0]
            
            # Validate the file path (must be in /captures directory)
            if not file_path.startswith('/captures/'):
                self.send_error(403, "Access denied")
                return
                
            if not os.path.exists(file_path):
                self.send_error(404, "File not found")
                return
                
            # Serve the file for download
            self.send_response(200)
            self.send_header('Content-type', 'application/octet-stream')
            self.send_header('Content-Disposition', f'attachment; filename="{os.path.basename(file_path)}"')
            self.end_headers()
            
            with open(file_path, 'rb') as f:
                self.wfile.write(f.read())
            return
        else:
            self.send_error(404, "File not found")
            return
    
    def list_capture_files(self):
        node_dir = f"/captures/{NODE_NAME}"
        files_html = []
        
        if os.path.exists(node_dir):
            pcap_files = glob.glob(f"{node_dir}/*.pcap*")
            
            if pcap_files:
                files_html.append("<table border='1' cellpadding='5' cellspacing='0'>")
                files_html.append("<tr><th>Interface</th><th>Size</th><th>Last Modified</th><th>Actions</th></tr>")
                
                for pcap_file in pcap_files:
                    interface = os.path.basename(pcap_file).replace('.pcap', '').replace('.pcap0', '')
                    
                    stat = os.stat(pcap_file)
                    size = f"{stat.st_size / (1024*1024):.2f} MB"
                    modified = datetime.datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
                    
                    files_html.append("<tr>")
                    files_html.append(f"<td>{interface}</td>")
                    files_html.append(f"<td>{size}</td>")
                    files_html.append(f"<td>{modified}</td>")
                    files_html.append(f"<td><a href='/download?file={pcap_file}'>Download</a></td>")
                    files_html.append("</tr>")
                
                files_html.append("</table>")
            else:
                files_html.append("<p>No capture files found on this node.</p>")
        else:
            files_html.append(f"<p>Capture directory {node_dir} not found.</p>")
        
        return "".join(files_html)

print(f"Starting HTTP server on port {PORT}")
with socketserver.TCPServer(("", PORT), CaptureHandler) as httpd:
    print(f"Serving at port {PORT}")
    httpd.serve_forever()
EOF

    # Start the web server
    echo "Starting Python HTTP server..."
    python3 /tmp/analysis/server.py